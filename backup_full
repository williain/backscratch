#!/usr/bin/env python3
import argparse
import datetime
import sys
import os
import hashlib
import stat
import time

def message(msg):
    if not args.quiet:
        print(msg)

def messagev(v, msg):
    if args.verbose>=v:
        message(msg)

def do_func(func_str):
    if not args.dryrun:
        exec(func_str)
    else:
        message(func_str)

def read_link(linkpath):
    po=os.popen('readlink "'+linkpath+'"')
    out=po.read()
    if po.close():
        print('ERROR: Error calling readlink on {}: {}'.format(linkpath, out))
        exit(5)
    return out.strip()

def make_link(source, dest, checksums):
    target=read_link(source)
    relative=False
    if not target.startswith(os.path.sep):
        # Note: This test really won't work on windows!
        relative=True
        longtarget=os.path.join(os.path.dirname(source),target)
    else:
        longtarget=target # Absolute path
    longtarget=os.path.abspath(longtarget)
    #Validate target as actually being part of the backup
    if not longtarget.startswith(sourcefolder):
        if args.force:
          sig='WARNING'
        else:
          sig='ERROR'
        message("{}: Link ".format(sig)+
          "{} can't be backed up; target {} outside of backup space {}".format(
            source, target, sourcefolder
        ))
        if args.force:
            xit=4
        else:
            exit(4)
    else:
        #Rewrite absolute paths
        if not relative:
            newtarget=os.path.join(destfolder,longtarget[1:])
        else:
            newtarget=target
        #Actually make the links!
        do_func('os.symlink("{}","{}")'.format(newtarget,dest))
        st=os.lstat(source)
        do_func('os.lchown("{}",{},{})'.format(dest,st.st_uid,st.st_gid))
        messagev(1, '{} (symlink)'.format(dest))
        if checksums:
            checksums.write('symlink:{}  {}\n'.format(target,source))

def transfer_file(root,f,checksums=None):
    source=os.path.join(root, f)
    dest=os.path.join(destfolder+root, f)
    st=os.lstat(source)
    if stat.S_ISLNK(st.st_mode):
        make_link(source,dest,checksums)
    else:
        time_s=time.time()
        infile=open(source,'rb')
        outfile=None
        if not args.dryrun:
            outfile=open(dest,'wb')
        h=hashlib.sha256()
        for data in infile.read(0x10000).decode(encoding='Latin1'):
            # 64k blocks
            data=data.encode(encoding='Latin1')
            h.update(data)
            if outfile:
                outfile.write(data)
        if outfile:
            outfile.close()
        infile.close()
        do_func('os.chmod("{}",{})'.format(dest, st.st_mode))
        do_func('os.chown("{}",{},{})'.format(dest, st.st_uid, st.st_gid))

        if args.verbose:
            dur=time.time()-time_s
            speed=st.st_size / dur
            if speed>2**10:
                if speed>2**20:
                    if speed>2**30:
                        speed=str(speed/2**30)+'Gi'
                    else:
                        speed=str(speed/2**20)+'Mi'
                else:
                    speed=str(speed/2**10)+'Ki'
            else:
                speed=str(speed)
            message('{} {}B/s'.format(dest, speed))

        if checksums:
            checksums.write('{}  {}\n'.format(h.hexdigest(), source))
        messagev(2, '{}  {}'.format(h.hexdigest(), source))

def transfer_dir(root,d,checksums=None):
    source=os.path.join(root, d)
    dest=os.path.join(destfolder+root, d)
    st=os.lstat(source)
    if stat.S_ISLNK(st.st_mode):
        make_link(source,dest,checksums)
    else:
        do_func('os.mkdir("{}")'.format(dest))
        do_func('os.chmod("{}",{})'.format(
          dest, st.st_mode)
        )
        do_func('os.chown("{}",{},{})'.format(
          dest, st.st_uid, st.st_gid
        ))
        messagev(1, '{} (dir)'.format(dest))
        if checksums: checksums.write('dir  {}\n'.format(source))

# -------------------------------------------------------------------------

p=argparse.ArgumentParser(
  description="Backup specified folder to a mounted volume",
  epilog="Error exit states:... 2 - Incorrect parameters;... 3 - Invalid "+
    "target path;... 4 - Invalid link found; backup will be incomplete (to a "+
    "greater or lesser extent depending on whether --force was used)"
)
p.add_argument('--verbose', '-v', action='count',
  help="List files as they're backed up. With -vv also print ssh hashes."
)
p.add_argument('--quiet', '-q', action='store_true',
  help='Don\'t even report the backup. Overrides --verbose'
)
p.add_argument('--dryrun', '-n', action='store_true',
  help='Do a read-only run. Implies -v (unless --quiet is specified)'
)
p.add_argument('target', help='The folder to back up')
p.add_argument('machine_id',
  help='Name of the machine being backed up. '+
    'Used as part of the backed-up directory name'
)
p.add_argument('--mount_point', default='/mnt',
  help='Where the backup drive is mounted. Defaults to /mnt.'
)
p.add_argument('--force', '-f', action='store_true',
  help='Demote fatal errors about bad links to warnings, and continue backup.'
)
p.add_argument('--incremental', '-i', default=None,
  help='Create an incremental backup based on the specified previous backup'
)
args=p.parse_args()
if args.quiet:
    args.verbose=0
if args.dryrun:
    if not args.verbose:
        args.verbose=1

xit=0
machine_id=args.machine_id
sourcefolder=args.target
backupfolder=os.path.join(args.mount_point,"backup_{:s}_{:%Y-%m-%d}".format(
  machine_id, datetime.date.today()
))
destfolder=os.path.join(backupfolder,'data')

if not os.path.isdir(sourcefolder):
    p.print_usage()
    print("Backup target '{}' must be a real directory".format(sourcefolder))
    exit(3)

if not sourcefolder.endswith(os.path.sep):
    # Add a path separator
    sourcefolder=sourcefolder+os.path.sep

if os.path.isdir(backupfolder) and not args.dryrun:
    print("Backup folder '{}' already exists; backup cancelled".format(
      backupfolder
    ))
    exit(3)

if args.incremental:
    incrpath=os.path.join(args.incremental, 'metadata', 'checksums.sha256')
    if not os.path.isdir(args.incremental):
        print("Incremental comparison must be a directory; not {}".format(
          args.incremental
        ))
        exit(3)
    elif not os.path.isfile(incrpath):
        print("Incremental comparison directory must contain a",
          "metadata/checksums.sha256 file"
        )
        exit(3)
    else:
        message('Incremental backup from {:s} to {:s} using {:s}'.format(
          sourcefolder, backupfolder, args.incremental
        ))
        inc=open(incrpath,'r')
        incr={}
        for l in inc.readlines():
            l=l.strip('\n')

            if l.startswith('symlink:'):
                (target, _, source)=l[len('symlink:'):].partition('  ')
                incr[source]='s:'+target
            elif l.startswith('dir  '):
                incr[l[len('dir  '):]]='d'
            else:
                (checksum, _, source)=l.partition('  ')
                if len(checksum) != 256//4:
                    message(
                       'Checksum file entry for {}'.format(source)+
                       ' is the wrong number of bits; forcing re-backup'
                    )
                else:
                    incr[source]='c:'+checksum
        inc.close()
else:
    message('Backing up from {:s} to {:s}'.format(sourcefolder, backupfolder))
    incr=None

do_func('os.mkdir("{}")'.format(backupfolder))
do_func('os.mkdir("{}")'.format(os.path.join(backupfolder,'metadata')))
checksums=None
if not args.dryrun:
    checksums=open(os.path.join(
      backupfolder, 'metadata', 'checksums.sha256'
    ),'w')

sourcefolder=os.path.abspath(sourcefolder)
if not sourcefolder.endswith(os.path.sep):
    sourcefolder=sourcefolder+os.path.sep

p=destfolder
do_func('os.mkdir("{}")'.format(p))
for d in sourcefolder.split(os.path.sep):
    if d!='':
        p=os.path.join(p,d)
        do_func('os.mkdir("{}")'.format(p))

if incr:
    for (p, ds, fis) in os.walk(sourcefolder):
        for d in ds:
            di=os.path.join(p, d)
            if di in incr.keys():
                c=incr[di]
            else:
                c=''

            if c == '':
                messagev(1, '{}: new directory'.format(di))
                transfer_dir(p, d, checksums)
            elif c == 'd':
                if os.path.islink(di):
                    messagev(1, '{}: was directory; '.format(di)+
                      'now symlink dir'
                    )
                    transfer_dir(p, d, checksums)
                # else is still a dir!
            elif c.startswith('c:'):
                if os.path.islink(di):
                    messagev(1, '{}: was file; now symlink dir'.format(di))
                else:
                    messagev(1,'{}: was file; now directory'.format(di))
                transfer_dir(p, d, checksums)
            elif c.startswith('s:'):
                if os.path.islink(di):
                    target=read_link(di)
                    if c[len('s:'):] != target:
                        messagev(1, '{}: Changed symlink dir target; '.format(
                          di) + 'was {} '.format(
                          c[len('s:'):]) + 'now {}'.format(target)
                        )
                        transfer_dir(p, d, checksums)
                else:
                    messagev(1, '{}: was symlink; now directory'.format(di))
                    transfer_dir(p, d, checksums)
        for fi in fis:
            fil=os.path.join(p, fi)
            if fil in incr.keys():
                c=incr[fil]
            else:
                c=""

            if c=="":
                messagev(1, '{}: New file'.format(fil))
                transfer_file(p, fi, checksums)
            elif c.startswith('c:'):
                c=c[len('c:'):]
                if os.path.islink(fil):
                    messagev(1, '{}: Was file; is symlink'.format(fil))
                    transfer_file(p, fi, checksums)
                else:
                    po=os.popen('sha256sum "'+fil+'"')
                    o=po.read()
                    if po.close():
                        print('Error calling sha256sum:',o)
                        exit(5)
                    (n,_,_)=o.partition('  ')
                    if len(n)!=256//4:
                        print('{}: Error decoding sha256sum results:'.format(
                          fil
                        )+ o)
                        exit(5)
                    else:
                        if n!=c:
                            messagev(1, '{}: Changed checksum {};'.format(
                              fil, n
                            ), 'was {}'.format(c)
                            )
                            transfer_file(p, fi, checksums)
                        else:
                            if checksums:
                                checksums.write('{}  {}\n'.format(
                                  n, fil
                                ))
            elif c.startswith('s:'):
                if os.path.islink(fil):
                    target=read_link(fil)
                    if c[len('s:'):] != target:
                        messagev(1, '{}: Changed symlink target; '.format(
                          fil
                        )+'was {}; '.format(c[len('s:'):]
                        )+'now {}'.format(target)
                        )
                        transfer_file(p, fi, checksums)
                else:
                    messagev(1, '{}: was symlink; now file'.format(fil))
                    transfer_file(p, fi, checksums)
            else:
                # Was a dir
                if os.path.islink(fil):
                    messagev(1, '{}: Was directory; now symlink'.format(fil))
                else:
                    messagev(1, '{}: Was directory; now file'.format(fil))
                transfer_file(p, fi, checksums)
else:
    for f in os.walk(sourcefolder):
        for d in f[1]:
            transfer_dir(f[0],d,checksums)
        for fi in f[2]:
            transfer_file(f[0],fi,checksums)

if checksums:
  checksums.close()

exit(xit)
